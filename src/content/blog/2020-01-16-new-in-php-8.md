PHP 8, the new major PHP version, is expected to be released by the end of 2020. It's in very active development right now, so things are likely to change a lot in the upcoming months.

In this post I'll keep an up-to-date list of what's expected to come: new features, performance improvements and breaking changes. Because PHP 8 is a new major version, there's a higher chance of your code breaking. If you've kept up to date with the latest releases though, the upgrade shouldn't be too hard, since most breaking changes were deprecated before in the 7.* versions.

Besides breaking changes, PHP 8 also brings some nice new features such as [the JIT compiler](#jit-rfc) and [union types](#union-types-rfc); and there's more to come!

{{ ad:carbon }}

## New features

Starting with new features, remember that PHP 8 is still in active development, so this list will grow over time.

### Union types <small>[RFC](*https://wiki.php.net/rfc/union_types_v2)</small>

Given the dynamically typed nature of PHP, there are lots of cases where union types can be useful. Union types are a collection of two or more types which indicate that either one of those can be used.

```php
public function foo(<hljs type>Foo|Bar</hljs> $input): <hljs type>int|float</hljs>;
```

Note that `void` can never be part of a union type, since it indicates "no return value at all". Furthermore, `nullable` unions can be written using `|null`, or by using the existing `?` notation:

```php
public function foo(<hljs type>Foo|null</hljs> $foo): void;

public function bar(<hljs type>?Bar</hljs> $bar): void;
```

### JIT <small>[RFC](*https://wiki.php.net/rfc/jit)</small>

The JIT — just in time — compiler promises significant performance improvements, albeit not always within the context of web requests. There haven't been any accurate benchmarks done at this point, but they sure will come.

If you want to know more about what the JIT can do for PHP, you can read another post I wrote about it [here](*/blog/php-jit).

### Weak maps <small>[RFC](*https://wiki.php.net/rfc/weak_maps)</small>

Built upon the [weakrefs RFC](*https://wiki.php.net/rfc/weakrefs) that was added in PHP 7.4, a `WeakMap` implementation is added in PHP 8. `WeakMaps` hold references to objects, which don't prevent those objects from being garbage collected.

Take the example of ORMs, they often implement caches which hold references to entity classes to improve the performance of relations between entities. These entity objects can not be garbage collected, as long as this cache has a reference to them, even if the cache is the _only_ thing referencing them.

If this caching layer uses weak references and maps instead, PHP will garbage collect these objects when nothing else references them anymore. Especially in the case of ORMs, which can manage several hundreds, if not thousands of entities within a request; weak maps can offer a better, more resource friendly way of dealing with these objects.

Here's what weak maps look like, an example from the RFC:

```php
class Foo 
{
    private <hljs type>WeakMap</hljs> $cache;
 
    public function getSomethingWithCaching(<hljs type>object</hljs> $obj): object
    {
        return $this->cache[$obj]
           ??= $this-><hljs prop>computeSomethingExpensive</hljs>($obj);
    }
}
```

### Create DateTime objects from interface

You can already create a `DateTime` object from a `DateTimeImmutable` object using `DateTime::createFromImmutable($immutableDateTime)`, but the other way around was tricky. By adding `DateTime::createFromInterface()` and `DatetimeImmutable::createFromInterface()` there's now a generalised way to convert `DateTime` and `DateTimeImmutable` objects to each other.

```php
<hljs type>DateTime</hljs>::<hljs prop>createFromInterface</hljs>(<hljs type>DateTimeInterface</hljs> $other);

<hljs type>DateTimeImmutable</hljs>::<hljs prop>createFromInterface</hljs>(<hljs type>DateTimeInterface</hljs> $other);
``` 

### `fdiv` function <small>[PR](*https://github.com/php/php-src/pull/4769)</small>

The new `fdiv` function does something similar as the `fmod` and `intdiv` functions, which allows for division by 0. Instead of errors you'll get `INF`, `-INF` or `NAN`, depending on the case. 

## Breaking changes

As mentioned before: this is a major update and thus there will be breaking changes. The best thing to do is take a look at the full list of breaking changes over at the [UPGRADING](*https://github.com/php/php-src/blob/master/UPGRADING#L20) document.

Many of these breaking changes have been deprecated in previous 7.* versions though, so I've you been staying up-to-date over the years, it shouldn't be all that hard to upgrade to PHP 8.

### Consistent type errors <small>[RFC](*https://wiki.php.net/rfc/consistent_type_errors)</small>

User-defined functions in PHP will already throw `TypeErrors`, but internal functions did not, they rather omitted warnings and returned `null`. As of PHP 8 the behaviour of internal functions have been made consistent. 

### Default error reporting level

It's now `E_ALL` instead of everything but `E_NOTICE` and `E_DEPRECATED`. This means that many errors might pop up which were previously silently ignored, though probably already existent before PHP 8.

### The @ operator no longer silences fatal errors

It's possible that this change might reveal errors that again were hidden before PHP 8. Make sure to set `display_errors=Off` on your production servers!

### Concatenation precedence <small>[RFC](*https://wiki.php.net/rfc/concatenation_precedence)</small>

While already deprecated in PHP 7.4, this change is now taken into effect. If you'd write something like this:

```php
echo "sum: " . $a + $b;
```

PHP would previously interpret it like this:

```php
echo ("sum: " . $a) + $b;
```

PHP 8 will make it so that it's interpreted like this:

```php
echo "sum: " . ($a + $b);
```

### Reflection method signature changes

Three method signatures of reflection classes have been changed:

```php
<hljs type>ReflectionClass</hljs>::<hljs prop>newInstance</hljs>($args);
<hljs type>ReflectionFunction</hljs>::<hljs prop>invoke</hljs>($args);
<hljs type>ReflectionMethod</hljs>::<hljs prop>invoke</hljs>($object, $args);
```

Have now become:

```php
<hljs type>ReflectionClass</hljs>::<hljs prop>newInstance</hljs>(...$args);
<hljs type>ReflectionFunction</hljs>::<hljs prop>invoke</hljs>(...$args);
<hljs type>ReflectionMethod</hljs>::<hljs prop>invoke</hljs>($object, ...$args);
```

The upgrading guide specifies that if you extend these classes, and still want to support both PHP 7 and PHP 8, the following signatures are allowed:

```php
<hljs type>ReflectionClass</hljs>::<hljs prop>newInstance</hljs>($arg = null, ...$args);
<hljs type>ReflectionFunction</hljs>::<hljs prop>invoke</hljs>($arg = null, ...$args);
<hljs type>ReflectionMethod</hljs>::<hljs prop>invoke</hljs>($object, $arg = null, ...$args);
```

### Several small deprecations

During the PHP 7.* development, several deprecations were added that are now finalised in PHP 8.

- Deprecations in [PHP 7.2](*https://wiki.php.net/rfc/deprecations_php_7_2)
- Deprecations in [PHP 7.3](*https://wiki.php.net/rfc/deprecations_php_7_3)
- Deprecations in [PHP 7.4](*https://wiki.php.net/rfc/deprecations_php_7_4)
