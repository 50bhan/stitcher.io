PHP 8 will be released on [November 26, 2020](*https://wiki.php.net/todo/php80). It's a new major version, which means that it will introduce some breaking changes, as well as lots of new features and performance improvements. PHP 8 is in very active development right now, with its first alpha expected on June 18, 2020. 

Because of the breaking changes, there's a higher chance you'll need to make some changes in your code to get it running on PHP 8. If you've kept up to date with the latest releases though, the upgrade shouldn't be too hard, since most breaking changes were deprecated before in the 7.* versions. And don't worry, all these deprecations are listed in this post.

Besides breaking changes, PHP 8 also brings a nice set of new features such as [the JIT compiler](#jit-rfc), [union types](#union-types-rfc), [attributes](#attributes-rfc), and more.

{{ ad:carbon }}

## New features

Starting with new features, remember that PHP 8 is still in active development, so this list will grow over time.

---

### Union types <small>[RFC](*https://wiki.php.net/rfc/union_types_v2)</small>

Given the dynamically typed nature of PHP, there are lots of cases where union types can be useful. Union types are a collection of two or more types which indicate that either one of those can be used.

```php
public function foo(<hljs type>Foo|Bar</hljs> $input): <hljs type>int|float</hljs>;
```

Note that `void` can never be part of a union type, since it indicates "no return value at all". Furthermore, `nullable` unions can be written using `|null`, or by using the existing `?` notation:

```php
public function foo(<hljs type>Foo|null</hljs> $foo): void;

public function bar(<hljs type>?Bar</hljs> $bar): void;
```

---

### JIT <small>[RFC](*https://wiki.php.net/rfc/jit)</small>

The JIT — just in time — compiler promises significant performance improvements, albeit not always within the context of web requests. There haven't been any accurate benchmarks done at this point, but they sure will come.

If you want to know more about what the JIT can do for PHP, you can read another post I wrote about it [here](/blog/php-jit).

---

### Attributes <small>[RFC](*https://wiki.php.net/rfc/attributes_v2)</small>

Attributes, commonly known as _annotations_ in other languages, offers a way to add meta data to classes, without having to parse docblocks.

As for a quick look, here's an example of what attributes look like, from the RFC:

```php
use App\Attributes\ExampleAttribute;

<<<hljs type>ExampleAttribute</hljs>>>
class Foo
{
    <<<hljs type>ExampleAttribute</hljs>>>
    public const FOO = 'foo';
 
    <<<hljs type>ExampleAttribute</hljs>>>
    public $x;
 
    <<<hljs type>ExampleAttribute</hljs>>>
    public function foo(<<<hljs type>ExampleAttribute</hljs>>> $bar) { }
}
```

```php
<<<hljs type>Attribute</hljs>>>
class ExampleAttribute
{
    public $value;
 
    public function __construct($value)
    {
        $this->value = $value;
    }
}
```

Note that this base `Attribute` used to be called `PhpAttribute` in the original RFC, but was changed with [another RFC](*https://wiki.php.net/rfc/attribute_amendments) afterwards. If you want to take a deep dive in how attributes work, and how you can build your own; you can read about [attributes in depth](/blog/attributes-in-php-8) on this blog.

---

### Constructor property promotion <small>[RFC](*https://wiki.php.net/rfc/constructor_promotion)</small>

This RFC adds syntactic sugar to create value objects or data transfer objects. Instead of specifying class properties and a constructor for them, PHP can now combine them into one.

Instead of doing this:

```php
class Money 
{
    public <hljs type>Currency</hljs> <hljs prop>$currency</hljs>;
 
    public <hljs type>int</hljs> <hljs prop>$amount</hljs>;
 
    public function __construct(
        <hljs type>Currency</hljs> $currency,
        <hljs type>int</hljs> $amount,
    ) {
        $this-><hljs prop>currency</hljs> = $currency;
        $this-><hljs prop>amount</hljs> = $amount;
    }
}
```

You can now do this:

```php
class Money 
{
    public function __construct(
        <hljs keyword>public</hljs> <hljs type>Currency</hljs> $currency,
        <hljs keyword>public</hljs> <hljs type>int</hljs> $amount,
    ) {}
}
```

There's a lot more to tell about property promotion, you can read about them [in this dedicated post](/blog/constructor-promotion-in-php-8).

---

### New `static` return type <small>[RFC](*https://wiki.php.net/rfc/static_return_type)</small>

While it was already possible to return `self`, `static` wasn't a valid return type until PHP 8. Given PHP's dynamically typed nature, it's a feature that will be useful to many developers.

```php
class Foo
{
    public function test(): static
    {
        return new static();
    }
}
```

---

### New `mixed` type <small>[RFC](*https://wiki.php.net/rfc/mixed_type_v2)</small>

Some might call it a necessary evil: the `mixed` type causes many to have mixed feelings. There's a very good argument to make for it though: a missing type can mean lots of things in PHP:

- A function returns nothing or null
- We're expecting one of several types
- We're expecting a type that can't be type hinted in PHP

Because of the reasons above, it's a good thing the `mixed` type is added. `mixed` itself means one of these types:

- `array`
- `bool`
- `callable`
- `int`
- `float`
- `null`
- `object`
- `resource`
- `string`

Note that `mixed` can also be used as a parameter or property type, not just as a return type.

Also note that since `mixed` already includes `null`, it's not allowed to make it nullable. The following will trigger an error:

```php
// Fatal error: Mixed types cannot be nullable, null is already part of the mixed type.
function bar(): <hljs type striped>?mixed</hljs> {}
``` 

---

### Throw expression <small>[RFC](*https://wiki.php.net/rfc/throw_expression)</small>

This RFC changes `throw` from being a statement to being an expression, which makes it possible to throw exception in many new places:

```php
$triggerError = <hljs keyword>fn</hljs> () => throw new <hljs type>MyError</hljs>();

$foo = $bar['offset'] ?? throw new <hljs type>OffsetDoesNotExist</hljs>('offset');
```

---

### Inheritance with private methods <small>[RFC](*https://wiki.php.net/rfc/inheritance_private_methods)</small>

Previously, PHP used to apply the same inheritance checks on public, protected and private methods. In other words: private methods should follow the same method signature rules as protected and public methods. This doesn't make sense, since private methods won't be accessible by child classes. 

This RFC changed that behaviour, so that these inheritance checks are not performed on private methods anymore. Furthermore, the use of `final private function` also didn't make sense, so doing so will now trigger a warning:

```
Warning: Private methods cannot be final as they are never overridden by other classes
```

---

### Weak maps <small>[RFC](*https://wiki.php.net/rfc/weak_maps)</small>

Built upon the [weakrefs RFC](*https://wiki.php.net/rfc/weakrefs) that was added in PHP 7.4, a `WeakMap` implementation is added in PHP 8. `WeakMaps` hold references to objects, which don't prevent those objects from being garbage collected.

Take the example of ORMs, they often implement caches which hold references to entity classes to improve the performance of relations between entities. These entity objects can not be garbage collected, as long as this cache has a reference to them, even if the cache is the _only_ thing referencing them.

If this caching layer uses weak references and maps instead, PHP will garbage collect these objects when nothing else references them anymore. Especially in the case of ORMs, which can manage several hundreds, if not thousands of entities within a request; weak maps can offer a better, more resource friendly way of dealing with these objects.

Here's what weak maps look like, an example from the RFC:

```php
class Foo 
{
    private <hljs type>WeakMap</hljs> $cache;
 
    public function getSomethingWithCaching(<hljs type>object</hljs> $obj): object
    {
        return $this->cache[$obj]
           ??= $this-><hljs prop>computeSomethingExpensive</hljs>($obj);
    }
}
```

---

### Allowing `::class` on objects <small>[RFC](*https://wiki.php.net/rfc/class_name_literal_on_object)</small>

A small, yet useful, new feature: it's now possible to use `::class` on objects, instead of having to use `get_class()` on them. It works the same way as `get_class()`.

```txt
$foo = <hljs keyword>new</hljs> <hljs type>Foo</hljs>();

<hljs prop>var_dump</hljs>($foo::<hljs keyword>class</hljs>);
```

---

### Non-capturing catches <small>[RFC](*https://wiki.php.net/rfc/non-capturing_catches)</small>

Whenever you wanted to catch an exception before PHP 8, you had to store it in a variable, regardless whether you used that variable or not. With non-capturing catches, you can omit the variable, so instead of this:

```php
try {
    // Something goes wrong
} catch (<hljs type>MySpecialException</hljs> $exception) {
    <hljs type>Log</hljs>::<hljs prop>error</hljs>("Something went wrong");
}
```

You can now do this:

```php
try {
    // Something goes wrong
} catch (<hljs type>MySpecialException</hljs>) {
    <hljs type>Log</hljs>::<hljs prop>error</hljs>("Something went wrong");
}
```

Note that it's required to always specify the type, you're not allowed to have an empty `catch`. If you want to catch all exceptions and errors, you can use `Throwable` as the catching type. 

---

### Trailing comma in parameter lists <small>[RFC](*https://wiki.php.net/rfc/trailing_comma_in_parameter_list)</small>

Already possible when calling a function, trailing comma support was still lacking in parameter lists. It's now allowed in PHP 8, meaning you can do the following:

```php
public function(
    <hljs type>string</hljs> $parameterA,
    <hljs type>int</hljs> $parameterB,
    <hljs type>Foo</hljs> $objectfoo<hljs green>,</hljs>
) {
    // …
}
```  

---

### Create `DateTime` objects from interface

You can already create a `DateTime` object from a `DateTimeImmutable` object using `DateTime::createFromImmutable($immutableDateTime)`, but the other way around was tricky. By adding `DateTime::createFromInterface()` and `DatetimeImmutable::createFromInterface()` there's now a generalised way to convert `DateTime` and `DateTimeImmutable` objects to each other.

```php
<hljs type>DateTime</hljs>::<hljs prop>createFromInterface</hljs>(<hljs type>DateTimeInterface</hljs> $other);

<hljs type>DateTimeImmutable</hljs>::<hljs prop>createFromInterface</hljs>(<hljs type>DateTimeInterface</hljs> $other);
``` 

---

### New `Stringable` interface <small>[RFC](*https://wiki.php.net/rfc/stringable)</small>

The `Stringable` interface can be used to type hint anything that is a string or implements `__toString()`. Furthermore, whenever a class implements `__toString()`, it automatically implements the interface behind the scenes and there's no need to manually implement it.

```php
class Foo
{
    public function __toString(): string
    {
        return 'foo';
    }
}

function bar(<hljs type>Stringable</hljs> $stringable) { /* … */ }

<hljs prop>bar</hljs>(new <hljs type>Foo</hljs>());
<hljs prop>bar</hljs>('abc');
```

---

### New `str_contains()` function <small>[RFC](*https://wiki.php.net/rfc/str_contains)</small>

Some might say it's long overdue, but we finally don't have to rely on `strpos` anymore to know whether a string contains another string.

Instead of doing this:

```php
if (<hljs prop>strpos</hljs>('string with lots of words', 'words') !== false) { /* … */ }
``` 

You can now do this

```php
if (<hljs prop>str_contains</hljs>('string with lots of words', 'words')) { /* … */ }
```

---

### New `str_starts_with()` and `str_ends_with()` functions <small>[RFC](*https://wiki.php.net/rfc/add_str_starts_with_and_ends_with_functions)</small>

Two other ones long overdue, these two functions are now added in the core.

```php
<hljs prop>str_starts_with</hljs>('haystack', 'hay'); // true
<hljs prop>str_ends_with</hljs>('haystack', 'stack'); // true
```

---

### New `fdiv()` function <small>[PR](*https://github.com/php/php-src/pull/4769)</small>

The new `fdiv()` function does something similar as the `fmod()` and `intdiv()` functions, which allows for division by 0. Instead of errors you'll get `INF`, `-INF` or `NAN`, depending on the case. 

---

### New `get_debug_type()` function <small>[RFC](*https://wiki.php.net/rfc/get_debug_type)</small>

`get_debug_type()` returns the type of a variable. Sounds like something `gettype()` would do? `get_debug_type()` returns more useful output for arrays, strings, anonymous classes and objects.

For example, calling `gettype()` on a class `\Foo\Bar` would return `object`. Using `get_debug_type()` will return the class name.

A full list of differences between `get_debug_type()` and `gettype()` can be found in the RFC.

---

### New `get_resource_id()` function <small>[PR](*https://github.com/php/php-src/pull/5427)</small>

Resources are special variables in PHP, referring to external resources. One example is a MySQL connection, another one a file handle. 

Each one of those resources gets assigned an ID, though previously the only way to know that id was to cast the resource to `int`:

```php
$resourceId = (int) $resource;
```

PHP 8 adds the `get_resource_id()` functions, making this operation more obvious and type-safe:

```php
$resourceId = get_resource_id($resource);
```

---

### Abstract methods in traits improvements <small>[RFC](*https://wiki.php.net/rfc/abstract_trait_method_validation)</small>

Traits can specify abstract methods which must be implemented by the classes using them. There's a caveat though: before PHP 8 the signature of these method implementations weren't validated. The following was valid:

```php
trait <hljs type>Test</hljs> {
    abstract public function test(<hljs type>int</hljs> $input): int;
}

class UsesTrait
{
    use <hljs type>Test</hljs>;

    public function test($input)
    {
        return $input;
    }
}
```

PHP 8 will perform proper method signature validation when using a trait and implementing its abstract methods. This means you'll need to write this instead:

```php
class UsesTrait
{
    use <hljs type>Test</hljs>;

    public function test(<hljs type>int</hljs> $input): int
    {
        return $input;
    }
}
```

---

### Object implementation of `token_get_all()` <small>[RFC](*https://wiki.php.net/rfc/token_as_object)</small>

The `token_get_all()` function returns an array of values. This RFC adds a `PhpToken` class with a `PhpToken::getAll()` method. This implementation works with objects instead of plain values. It consumes less memory and is easier to read.

---

### Variable syntax tweaks <small>[RFC](*https://wiki.php.net/rfc/variable_syntax_tweaks)</small>

From the RFC: "the Uniform Variable Syntax RFC resolved a number of inconsistencies in PHP's variable syntax. This RFC intends to address a small handful of cases that were overlooked." 

---

### Type annotations for internal functions <small>[EXTERNALS](*https://externals.io/message/106522)</small>

Lots of people [pitched in](*https://github.com/php/php-src/pulls?q=is%3Apr+label%3AStubs+is%3Aclosed) to add proper type annotations to all internal functions. This was a long standing issue, and finally solvable with all the changes made to PHP in previous versions. This means that internal functions and methods will have complete type information in reflection.

---

### `ext-json` always available <small>[RFC](*https://wiki.php.net/rfc/always_enable_json)</small>

Previously it was possible to compile PHP without the JSON extension enabled, this is not possible anymore. Since JSON is so widely used, it's best developers can always rely on it being there, instead of having to ensure the extension exist first.

## Breaking changes

As mentioned before: this is a major update and thus there will be breaking changes. The best thing to do is take a look at the full list of breaking changes over at the [UPGRADING](*https://github.com/php/php-src/blob/master/UPGRADING#L20) document.

Many of these breaking changes have been deprecated in previous 7.* versions though, so if you've been staying up-to-date over the years, it shouldn't be all that hard to upgrade to PHP 8.

---

### Consistent type errors <small>[RFC](*https://wiki.php.net/rfc/consistent_type_errors)</small>

User-defined functions in PHP will already throw `TypeErrors`, but internal functions did not, they rather emitted warnings and returned `null`. As of PHP 8 the behaviour of internal functions have been made consistent. 

---

### Reclassified engine warnings <small>[RFC](*https://wiki.php.net/rfc/engine_warnings)</small>

Lots of errors that previously only triggered warnings or notices, have been converted to proper errors. The following warnings were changed.

- Undefined variable: `Error` exception instead of notice
- Undefined array index: warning instead of notice
- Division by zero: `DivisionByZeroError` exception instead of warning
- Attempt to increment/decrement property '%s' of non-object: `Error` exception instead of warning
- Attempt to modify property '%s' of non-object: `Error` exception instead of warning
- Attempt to assign property '%s' of non-object: `Error` exception instead of warning
- Creating default object from empty value: `Error` exception instead of warning
- Trying to get property '%s' of non-object: warning instead of notice
- Undefined property: %s::$%s: warning instead of notice
- Cannot add element to the array as the next element is already occupied: `Error` exception instead of warning
- Cannot unset offset in a non-array variable: `Error` exception instead of warning
- Cannot use a scalar value as an array: `Error` exception instead of warning
- Only arrays and `Traversables` can be unpacked: `TypeError` exception instead of warning
- Invalid argument supplied for foreach(): `TypeError` exception instead of warning
- Illegal offset type: `TypeError` exception instead of warning
- Illegal offset type in isset or empty: `TypeError` exception instead of warning
- Illegal offset type in unset: `TypeError` exception instead of warning
- Array to string conversion: warning instead of notice
- Resource ID#%d used as offset, casting to integer (%d): warning instead of notice
- String offset cast occurred: warning instead of notice
- Uninitialized string offset: %d: warning instead of notice
- Cannot assign an empty string to a string offset: `Error` exception instead of warning
- Supplied resource is not a valid stream resource: `TypeError` exception instead of warning

---

### The @ operator no longer silences fatal errors

It's possible that this change might reveal errors that again were hidden before PHP 8. Make sure to set `display_errors=Off` on your production servers!

---

### Default error reporting level

It's now `E_ALL` instead of everything but `E_NOTICE` and `E_DEPRECATED`. This means that many errors might pop up which were previously silently ignored, though probably already existent before PHP 8.

---

### Default PDO error mode <small>[RFC](*https://wiki.php.net/rfc/pdo_default_errmode)</small>

From the RFC: _The current default error mode for PDO is silent. This means that when an SQL error occurs, no errors or warnings may be emitted and no exceptions thrown unless the developer implements their own explicit error handling._

This RFC changes the default error will change to `PDO::ERRMODE_EXCEPTION` in PHP 8.

---

### Concatenation precedence <small>[RFC](*https://wiki.php.net/rfc/concatenation_precedence)</small>

While already deprecated in PHP 7.4, this change is now taken into effect. If you'd write something like this:

```php
echo "sum: " . $a + $b;
```

PHP would previously interpret it like this:

```php
echo ("sum: " . $a) + $b;
```

PHP 8 will make it so that it's interpreted like this:

```php
echo "sum: " . ($a + $b);
```

---

### Stricter type checks for arithmetic and bitwise operators <small>[RFC](*https://wiki.php.net/rfc/arithmetic_operator_type_checks)</small>

Before PHP 8, it was possible to apply arithmetic or bitwise operators on arrays, resources or objects. This isn't possible anymore, and will throw a `TypeError`:

```php
[] <hljs error>%</hljs> [42];
$object <hljs error>+</hljs> 4;
```   

---

### Reflection method signature changes

Three method signatures of reflection classes have been changed:

```php
<hljs type>ReflectionClass</hljs>::<hljs prop>newInstance</hljs>($args);
<hljs type>ReflectionFunction</hljs>::<hljs prop>invoke</hljs>($args);
<hljs type>ReflectionMethod</hljs>::<hljs prop>invoke</hljs>($object, $args);
```

Have now become:

```php
<hljs type>ReflectionClass</hljs>::<hljs prop>newInstance</hljs>(...$args);
<hljs type>ReflectionFunction</hljs>::<hljs prop>invoke</hljs>(...$args);
<hljs type>ReflectionMethod</hljs>::<hljs prop>invoke</hljs>($object, ...$args);
```

The upgrading guide specifies that if you extend these classes, and still want to support both PHP 7 and PHP 8, the following signatures are allowed:

```php
<hljs type>ReflectionClass</hljs>::<hljs prop>newInstance</hljs>($arg = null, ...$args);
<hljs type>ReflectionFunction</hljs>::<hljs prop>invoke</hljs>($arg = null, ...$args);
<hljs type>ReflectionMethod</hljs>::<hljs prop>invoke</hljs>($object, $arg = null, ...$args);
```

---

### Stable sorting <small>[RFC](*https://wiki.php.net/rfc/stable_sorting)</small>

Before PHP 8, sorting algorithms were unstable. This means that the order of equal elements wasn't guaranteed. PHP 8 changes the behaviour of all sorting functions to stable sorting.

---

### Fatal error for incompatible method signatures <small>[RFC](*https://wiki.php.net/rfc/lsp_errors)</small>

From the RFC: _Inheritance errors due to incompatible method signatures currently either throw a fatal error or a warning depending on the cause of the error and the inheritance hierarchy._

---

### Other deprecations and changes

During the PHP 7.* development, several deprecations were added that are now finalised in PHP 8.

- Deprecations in [PHP 7.2](*https://wiki.php.net/rfc/deprecations_php_7_2)
- Deprecations in [PHP 7.3](*https://wiki.php.net/rfc/deprecations_php_7_3)
- Deprecations in [PHP 7.4](*https://wiki.php.net/rfc/deprecations_php_7_4)
- Locale-independent [float to string cast](*https://wiki.php.net/rfc/locale_independent_float_to_string)

---
